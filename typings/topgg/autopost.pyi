"""
This type stub file was generated by pyright.
"""

import asyncio
import datetime
import typing as t
from .types import StatsWrapper
from .client import DBLClient

__all__ = ["AutoPoster"]
if t.TYPE_CHECKING:
    ...
CallbackT = t.Callable[..., t.Any]
StatsCallbackT = t.Callable[[], StatsWrapper]
class AutoPoster:
    """
    A helper class for autoposting. Takes in a :obj:`~.client.DBLClient` to instantiate.

    Note:
        You should not instantiate this unless you know what you're doing.
        Generally, you'd better use the :meth:`~.client.DBLClient.autopost` method.

    Args:
        client (:obj:`~.client.DBLClient`)
            An instance of DBLClient.
    """
    __slots__ = ...
    _success: CallbackT
    _stats: CallbackT
    _interval: float
    _task: t.Optional[asyncio.Task[None]]
    def __init__(self, client: DBLClient) -> None:
        ...
    
    @t.overload
    def on_success(self, callback: None) -> t.Callable[[CallbackT], CallbackT]:
        ...
    
    @t.overload
    def on_success(self, callback: CallbackT) -> AutoPoster:
        ...
    
    def on_success(self, callback: t.Any = ...) -> t.Any:
        """
        Registers an autopost success callback. The callback can be either sync or async.

        The callback is not required to take in arguments, but you can have injected :obj:`~.data.data`.
        This method can be used as a decorator or a decorator factory.

        :Example:
            .. code-block:: python

                # The following are valid.
                autopost = dblclient.autopost().on_success(lambda: print("Success!"))


                # Used as decorator, the decorated function will become the AutoPoster object.
                @autopost.on_success
                def autopost(): ...


                # Used as decorator factory, the decorated function will still be the function itself.
                @autopost.on_success()
                def on_success(): ...
        """
        ...
    
    @t.overload
    def on_error(self, callback: None) -> t.Callable[[CallbackT], CallbackT]:
        ...
    
    @t.overload
    def on_error(self, callback: CallbackT) -> AutoPoster:
        ...
    
    def on_error(self, callback: t.Any = ...) -> t.Any:
        """
        Registers an autopost error callback. The callback can be either sync or async.

        The callback is expected to take in the exception being raised, you can also
        have injected :obj:`~.data.data`.
        This method can be used as a decorator or a decorator factory.

        Note:
            If you don't provide an error callback, the default error handler will be called.

        :Example:
            .. code-block:: python

                # The following are valid.
                autopost = dblclient.autopost().on_error(lambda exc: print("Failed posting stats!", exc))


                # Used as decorator, the decorated function will become the AutoPoster object.
                @autopost.on_error
                def autopost(exc: Exception): ...


                # Used as decorator factory, the decorated function will still be the function itself.
                @autopost.on_error()
                def on_error(exc: Exception): ...
        """
        ...
    
    @t.overload
    def stats(self, callback: None) -> t.Callable[[StatsCallbackT], StatsCallbackT]:
        ...
    
    @t.overload
    def stats(self, callback: StatsCallbackT) -> AutoPoster:
        ...
    
    def stats(self, callback: t.Any = ...) -> t.Any:
        """
        Registers a function that returns an instance of :obj:`~.types.StatsWrapper`.

        The callback can be either sync or async.
        The callback is not required to take in arguments, but you can have injected :obj:`~.data.data`.
        This method can be used as a decorator or a decorator factory.

        :Example:
            .. code-block:: python

                import topgg

                # In this example, we fetch the stats from a Discord client instance.
                client = Client(...)
                dblclient = topgg.DBLClient(TOKEN).set_data(client)
                autopost = dblclient.autopost().on_success(lambda: print("Successfully posted the stats!"))


                @autopost.stats()
                def get_stats(client: Client = topgg.data(Client)):
                    return topgg.StatsWrapper(guild_count=len(client.guilds), shard_count=len(client.shards))


                # somewhere after the event loop has started
                autopost.start()
        """
        ...
    
    @property
    def interval(self) -> float:
        """The interval between posting stats."""
        ...
    
    @interval.setter
    def interval(self, seconds: t.Union[float, datetime.timedelta]) -> None:
        """Alias to :meth:`~.autopost.AutoPoster.set_interval`."""
        ...
    
    def set_interval(self, seconds: t.Union[float, datetime.timedelta]) -> AutoPoster:
        """
        Sets the interval between posting stats.

        Args:
            seconds (Union[:obj:`float`, :obj:`datetime.timedelta`])
                The interval.

        Raises:
            ValueError
                If the provided interval is less than 900 seconds.
        """
        ...
    
    @property
    def is_running(self) -> bool:
        """Whether or not the autopost is running."""
        ...
    
    def start(self) -> asyncio.Task[None]:
        """
        Starts the autoposting loop.

        Note:
            This method must be called when the event loop has already running!

        Raises:
            :exc:`~.errors.TopGGException`
                If there's no callback provided or the autopost is already running.
        """
        ...
    
    def stop(self) -> None:
        """
        Stops the autoposting loop.

        Note:
            This differs from :meth:`~.autopost.AutoPoster.cancel`
            because this will post once before stopping as opposed to cancel immediately.
        """
        ...
    
    def cancel(self) -> None:
        """
        Cancels the autoposting loop.

        Note:
            This differs from :meth:`~.autopost.AutoPoster.stop`
            because this will stop the loop right away.
        """
        ...
    


